node -v
npm -v

Vue.js 프로젝트 생성 및 구조 가이드
이 가이드는 Visual Studio Code에서 Vue CLI를 사용하여 새로운 Vue.js 프로젝트를 생성하고, 이전에 제공된 프론트엔드 코드의 기능을 통합하는 방법을 단계별로 설명합니다.

1단계: 필수 도구 설치
Vue.js 프로젝트를 시작하기 전에 Node.js와 Vue CLI가 설치되어 있어야 합니다.

Node.js 및 npm (또는 Yarn) 설치 확인:
터미널을 열고 다음 명령어를 실행하여 설치 여부를 확인합니다.

node -v
npm -v
# 또는
yarn -v

설치되어 있지 않다면 Node.js 공식 웹사이트에서 다운로드하여 설치합니다. npm은 Node.js와 함께 설치됩니다.

Vue CLI 설치:
Vue CLI는 Vue.js 프로젝트를 빠르고 쉽게 생성하고 관리할 수 있도록 돕는 도구입니다. 전역으로 설치합니다.

npm install -g @vue/cli
# 또는
yarn global add @vue/cli

설치 후 다음 명령어로 버전 확인:

vue --version

2단계: 새로운 Vue 프로젝트 생성 (Vue CLI 사용)
이제 Vue CLI를 사용하여 새로운 프로젝트를 생성합니다.

프로젝트 생성 명령어 실행:
프로젝트를 생성할 디렉토리로 이동한 후, 터미널에서 다음 명령어를 실행합니다.

vue create lake-monitoring-frontend
```lake-monitoring-frontend`는 프로젝트 이름이며, 원하는 이름으로 변경할 수 있습니다.


프로젝트 설정 선택 (대화형 프롬프트):
명령어를 실행하면 Vue CLI가 몇 가지 질문을 합니다.

Please pick a preset:

Default (Vue 3): Vue 3와 Babel, ESLint를 포함한 기본 설정을 선택합니다. (권장)
Manually select features: 필요한 기능을 수동으로 선택할 수 있습니다.
이 프로젝트에서는 Router, Vuex (또는 Pinia), CSS Pre-processors (Tailwind CSS를 PostCSS와 함께 사용하기 위해)를 선택하는 것이 좋습니다.
TypeScript는 선택 사항이지만, 프로젝트의 복잡성에 따라 고려할 수 있습니다.
예시: Manually select features를 선택하고 다음을 선택할 수 있습니다.
Babel (기본)
TypeScript (선택 사항)
Progressive Web App (PWA) Support (선택 사항)
Router (필수)
Vuex (또는 Pinia - 상태 관리, 필수)
CSS Pre-processors (Tailwind CSS를 위한 PostCSS 설정 시 필요)
Linter / Formatter (코드 스타일 유지를 위해 권장)
Unit Testing (선택 사항)
E2E Testing (선택 사항)
각 선택 후 추가 질문에 답합니다.
Use history mode for router? (Y/n): Y를 눌러 HTML5 History Mode를 사용합니다. (URL에 #이 붙지 않습니다.)
Pick a CSS pre-processor (PostCSS, Less, Sass, Stylus): PostCSS를 선택합니다. (Tailwind CSS 설정에 필요)
Pick a linter / formatter config:: ESLint + Prettier (권장)
Pick additional lint features:: Lint on save (권장)
Where do you prefer placing config for Babel, ESLint, etc.?: In dedicated config files (권장)

Save this as a preset for future projects?: N (선택 사항)

프로젝트 생성 완료:
Vue CLI가 필요한 파일들을 다운로드하고 프로젝트를 설정합니다. 완료되면 다음 메시지가 표시됩니다.

Successfully created project lake-monitoring-frontend.
Get started with the following commands:

 cd lake-monitoring-frontend
 npm run serve

프로젝트 실행 확인:

cd lake-monitoring-frontend
npm run serve

브라우저에서 http://localhost:8080/ (또는 표시되는 URL)에 접속하여 기본 Vue 애플리케이션이 실행되는지 확인합니다.

3단계: 초기 프로젝트 구조 탐색 (자동 생성)
vue create 명령어로 생성된 lake-monitoring-frontend 프로젝트의 초기 디렉토리 구조는 다음과 같습니다. 이 구조는 이전에 설명한 Vue.js 디렉토리 구조와 거의 동일합니다.

lake-monitoring-frontend/
├── node_modules/           # 프로젝트 종속성
├── public/
│   ├── index.html          # 애플리케이션의 유일한 HTML 파일 (진입점)
│   └── favicon.ico
├── src/                    # 애플리케이션 소스 코드 (핵심)
│   ├── assets/             # 이미지, 폰트 등 정적 자산
│   │   └── logo.png
│   ├── components/         # 재사용 가능한 Vue 컴포넌트
│   │   └── HelloWorld.vue
│   ├── router/             # Vue Router 설정 (index.js)
│   │   └── index.js
│   ├── store/              # Vuex 또는 Pinia 상태 관리 설정 (index.js)
│   │   └── index.js
│   ├── views/              # 라우터에 매핑되는 페이지/뷰 컴포넌트
│   │   ├── HomeView.vue
│   │   └── AboutView.vue
│   ├── App.vue             # 최상위 루트 컴포넌트
│   └── main.js             # 애플리케이션 진입점 JavaScript
├── .gitignore              # Git 무시 파일
├── babel.config.js         # Babel 설정
├── package.json            # 프로젝트 메타데이터 및 종속성
├── README.md               # 프로젝트 설명
├── vue.config.js           # Vue CLI 설정 (선택 사항, 기본 생성 시 없을 수 있음)
└── postcss.config.js       # PostCSS 설정 (CSS Pre-processors 선택 시 생성)

자동 생성된 주요 파일 및 디렉토리의 역할:

public/index.html: 이 파일은 애플리케이션의 뼈대 역할을 합니다. Vue 앱은 이 파일의 <div id="app"></div> 요소에 마운트됩니다. 이전의 단일 HTML 파일과 달리, 이 파일은 Vue CLI가 빌드 과정에서 필요한 스크립트와 스타일을 자동으로 주입하는 템플릿 역할을 합니다.

src/main.js: Vue 애플리케이션의 진입점입니다. 여기서 Vue 앱 인스턴스를 생성하고, App.vue를 마운트하며, Vue Router, Vuex/Pinia, 전역 컴포넌트, 외부 라이브러리 등을 초기화하고 등록합니다.

src/App.vue: 애플리케이션의 최상위 컴포넌트입니다. 라우터 뷰(router-view)를 포함하여 각 경로에 따라 다른 뷰 컴포넌트(HomeView.vue, AboutView.vue 등)가 렌더링됩니다.

src/router/index.js: 애플리케이션의 URL 경로와 해당 경로에 렌더링될 뷰 컴포넌트를 정의합니다.

src/store/index.js: 전역 상태 관리를 위한 Vuex 또는 Pinia 스토어를 정의합니다.

src/components/: 재사용 가능한 UI 컴포넌트들을 정의합니다. HelloWorld.vue는 예시 컴포넌트입니다.

src/views/: 각 라우터 경로에 해당하는 페이지 수준의 컴포넌트들을 정의합니다. HomeView.vue, AboutView.vue는 예시 페이지입니다.

package.json: 프로젝트의 이름, 버전, 스크립트(serve, build 등), 그리고 프로젝트가 의존하는 모든 라이브러리(dependencies) 목록이 정의됩니다.

4단계: 프로젝트에 필요한 기능 추가 (추가 생성/설정)
이전 Canvas에서 제공된 단일 HTML 파일의 기능을 새로운 Vue CLI 프로젝트에 통합하기 위해 다음 단계를 수행합니다.

4.1. Tailwind CSS 설정
Tailwind CSS 설치:

cd lake-monitoring-frontend
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

이 명령은 tailwind.config.js와 postcss.config.js 파일을 생성합니다.

tailwind.config.js 설정:
생성된 tailwind.config.js 파일을 열고 content 섹션을 수정하여 Vue 컴포넌트 파일을 포함하도록 합니다.

// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}", // Vue 컴포넌트 파일 포함
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

src/assets/main.css (또는 src/index.css)에 Tailwind 지시문 추가:
프로젝트의 메인 CSS 파일(예: src/assets/main.css 또는 src/index.css - 프로젝트 생성 시점에 따라 다름)에 Tailwind CSS의 기본 스타일을 주입합니다.

/* src/assets/main.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

/* 추가적인 전역 스타일 */
body {
    font-family: 'Inter', sans-serif;
    background-color: #f0f4f8;
    color: #334155;
}
/* 기타 전역 스타일 (예: .card, .nav-link 등) */
.card {
    background-color: #ffffff;
    border-radius: 0.75rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    padding: 1.5rem;
    margin-bottom: 1.5rem;
}
.nav-link {
    padding: 0.75rem 1.25rem;
    border-radius: 0.5rem;
    transition: background-color 0.2s ease-in-out;
}
.nav-link:hover {
    background-color: #e2e8f0;
}
.nav-link.active {
    background-color: #3b82f6;
    color: #ffffff;
}
.btn-primary {
    background-color: #3b82f6;
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 0.5rem;
    transition: background-color 0.2s ease-in-out;
}
.btn-primary:hover {
    background-color: #2563eb;
}
.btn-danger {
    background-color: #ef4444;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    transition: background-color 0.2s ease-in-out;
}
.btn-danger:hover {
    background-color: #dc2626;
}
.btn-secondary {
    background-color: #6b7280;
    color: white;
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    transition: background-color 0.2s ease-in-out;
}
.btn-secondary:hover {
    background-color: #4b5563;
}
input, select, textarea {
    border: 1px solid #cbd5e0;
    border-radius: 0.5rem;
    padding: 0.75rem;
    width: 100%;
    box-sizing: border-box;
}
table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1rem;
}
th, td {
    border: 1px solid #e2e8f0;
    padding: 0.75rem;
    text-align: left;
}
th {
    background-color: #f8fafc;
    font-weight: 600;
}
#map {
    height: 500px;
    width: 100%;
    border-radius: 0.75rem;
}
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
}
.modal-content {
    background-color: white;
    padding: 2rem;
    border-radius: 0.75rem;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
    width: 90%;
    max-width: 500px;
}

main.js에서 CSS 파일 임포트:
src/main.js 파일에서 Tailwind CSS가 포함된 CSS 파일을 임포트하여 애플리케이션 전반에 적용되도록 합니다.

// src/main.js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store' // 또는 './store' (Vuex)
import './assets/main.css' // Tailwind CSS 및 전역 스타일 임포트

const app = createApp(App)

app.use(router)
app.use(store) // 또는 app.use(pinia)

app.mount('#app')

4.2. 외부 라이브러리 설치
이전 HTML 파일에서 사용된 외부 라이브러리들을 npm을 통해 설치합니다.

npm install axios chart.js firebase

4.3. Google Maps API 스크립트 추가
Google Maps API는 <script> 태그를 통해 로드해야 합니다. public/index.html 파일의 <head> 섹션에 추가합니다.

<!-- public/index.html -->
<head>
    <!-- ... 기존 내용 ... -->
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_GOOGLE_MAPS_API_KEY"></script>
    <!-- ... 기존 내용 ... -->
</head>

주의: YOUR_GOOGLE_MAPS_API_KEY를 실제 Google Maps API 키로 교체해야 합니다.

4.4. Vue 컴포넌트 및 라우팅 구성
이전 단일 HTML 파일의 각 섹션(디바이스 관리, 디바이스 상태, 로봇 위치 추적, 센서 데이터 차트, CCTV 이미지)을 별도의 Vue 컴포넌트(views 폴더)로 분리하고, Vue Router를 사용하여 이들을 연결합니다.

src/views/ 폴더에 컴포넌트 파일 생성:

DeviceManagementView.vue

DeviceStatusView.vue

RobotLocationView.vue

SensorDataChartView.vue

CCTVImagesView.vue

각 .vue 파일은 <template>, <script setup> (또는 <script>), <style> 섹션으로 구성됩니다. 이전 HTML 파일의 해당 섹션 내용을 복사하여 각 컴포넌트에 붙여넣고 Vue 3 Composition API 문법에 맞게 수정합니다.

예시: DeviceManagementView.vue의 기본 구조

<!-- src/views/DeviceManagementView.vue -->
<template>
    <div class="card">
        <h2 class="text-2xl font-semibold mb-4">디바이스 관리</h2>
        <!-- 이전 HTML의 디바이스 관리 폼 및 테이블 내용 -->
        <!-- ... -->
    </div>
    <!-- 삭제 확인 모달은 App.vue 또는 각 뷰에서 관리 가능 -->
    <div v-if="showDeleteModal" class="modal">
        <div class="modal-content">
            <h3 class="text-xl font-semibold mb-4">디바이스 삭제 확인</h3>
            <p class="mb-6">정말로 '{{ deviceToDeleteId }}' 디바이스를 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.</p>
            <div class="flex justify-end space-x-4">
                <button @click="cancelDelete" class="btn-secondary">취소</button>
                <button @click="deleteDevice" class="btn-danger">삭제</button>
            </div>
        </div>
    </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue';
import axios from 'axios';
import { getFirestore, doc, setDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from 'firebase/firestore';
import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { initializeApp } from 'firebase/app';

// Firebase 초기화 (main.js에서 한 번만 초기화하는 것이 좋음)
// 여기서는 편의상 각 뷰에 포함시키지만, 실제 앱에서는 전역적으로 관리
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

const API_BASE_URL = 'http://localhost:8080/api'; // 실제 백엔드 URL

const userId = ref(null);
const isAuthReady = ref(false);

// 디바이스 관리 관련 데이터 및 함수
const devices = ref([]);
const currentDevice = ref({ /* ... */ });
const isEditMode = ref(false);
const showDeleteModal = ref(false);
const deviceToDeleteId = ref(null);

// 인증 처리
onMounted(async () => {
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId.value = user.uid;
        } else {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    userId.value = auth.currentUser.uid;
                } catch (error) {
                    console.error("Custom token sign-in failed:", error);
                    await signInAnonymously(auth);
                    userId.value = auth.currentUser.uid;
                }
            } else {
                await signInAnonymously(auth);
                userId.value = auth.currentUser.uid;
            }
        }
        isAuthReady.value = true;
        console.log("Firebase Auth Ready. User ID:", userId.value);

        if (userId.value) {
            fetchDevices();
        }
    });
});

// Firestore 데이터 변경 감지 (실시간 동기화)
watch(isAuthReady, (ready) => {
    if (ready && userId.value) {
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const devicesCollectionRef = collection(db, `artifacts/${appId}/users/${userId.value}/devices`);

        onSnapshot(devicesCollectionRef, (snapshot) => {
            devices.value = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log("Devices updated from Firestore:", devices.value);
        }, (error) => {
            console.error("Error listening to devices:", error);
        });
    }
});

// 디바이스 관리 함수들 (fetchDevices, saveDevice, editDevice, confirmDeleteDevice, cancelDelete, deleteDevice, resetForm)
// 이전 HTML의 <script> 섹션에서 해당 함수들을 복사하여 여기에 붙여넣습니다.
// 각 함수 내의 `alert()`는 적절한 Vue 모달 컴포넌트 등으로 교체하는 것이 좋습니다.
const fetchDevices = async () => { /* ... */ };
const saveDevice = async () => { /* ... */ };
const editDevice = (device) => { /* ... */ };
const confirmDeleteDevice = (deviceId) => { /* ... */ };
const cancelDelete = () => { /* ... */ };
const deleteDevice = async () => { /* ... */ };
const resetForm = () => { /* ... */ };

</script>

<style scoped>
/* 이 컴포넌트에만 적용되는 스타일 */
</style>

src/router/index.js 설정:
생성된 뷰 컴포넌트들을 라우터에 등록합니다.

// src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import DeviceManagementView from '../views/DeviceManagementView.vue'
import DeviceStatusView from '../views/DeviceStatusView.vue'
import RobotLocationView from '../views/RobotLocationView.vue'
import SensorDataChartView from '../views/SensorDataChartView.vue'
import CCTVImagesView from '../views/CCTVImagesView.vue'

const routes = [
  {
    path: '/',
    name: 'device-management',
    component: DeviceManagementView
  },
  {
    path: '/device-status',
    name: 'device-status',
    component: DeviceStatusView
  },
  {
    path: '/robot-location',
    name: 'robot-location',
    component: RobotLocationView
  },
  {
    path: '/sensor-data-chart',
    name: 'sensor-data-chart',
    component: SensorDataChartView
  },
  {
    path: '/cctv-images',
    name: 'cctv-images',
    component: CCTVImagesView
  }
]

const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL), // Vue 3 Vite 기준
  // history: createWebHistory(process.env.BASE_URL), // Vue 3 Vue CLI 기준
  routes
})

export default router

src/App.vue 수정:
최상위 App.vue 컴포넌트에서 네비게이션과 router-view를 설정합니다. 이전 HTML 파일의 <nav> 섹션을 여기에 배치하고, 각 페이지 내용을 router-view로 대체합니다.

<!-- src/App.vue -->
<template>
  <div id="app" class="container">
    <!-- 사용자 인증 정보 표시 -->
    <div class="card flex justify-between items-center mb-6">
        <h1 class="text-3xl font-bold text-gray-800">호수 수질 관리 시스템</h1>
        <div v-if="userId" class="text-gray-600">
            사용자 ID: <span class="font-semibold">{{ userId }}</span>
        </div>
        <div v-else class="text-gray-600">
            인증 중...
        </div>
    </div>

    <!-- 네비게이션 -->
    <nav class="card flex space-x-4 p-4 mb-6">
        <router-link to="/" class="nav-link" :class="{'active': $route.name === 'device-management'}">디바이스 관리</router-link>
        <router-link to="/device-status" class="nav-link" :class="{'active': $route.name === 'device-status'}">디바이스 상태</router-link>
        <router-link to="/robot-location" class="nav-link" :class="{'active': $route.name === 'robot-location'}">로봇 위치 추적</router-link>
        <router-link to="/sensor-data-chart" class="nav-link" :class="{'active': $route.name === 'sensor-data-chart'}">센서 데이터 차트</router-link>
        <router-link to="/cctv-images" class="nav-link" :class="{'active': $route.name === 'cctv-images'}">CCTV 이미지</router-link>
    </nav>

    <!-- 라우터 뷰: 현재 경로에 해당하는 컴포넌트가 렌더링될 위치 -->
    <router-view></router-view>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { initializeApp } from 'firebase/app';

// Firebase 설정 및 초기화 (main.js에서 한 번만 하는 것이 좋지만, 여기서는 편의상 App.vue에 포함)
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);

const userId = ref(null);

onMounted(() => {
    onAuthStateChanged(auth, async (user) => {
        if (user) {
            userId.value = user.uid;
        } else {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                try {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    userId.value = auth.currentUser.uid;
                } catch (error) {
                    console.error("Custom token sign-in failed:", error);
                    await signInAnonymously(auth);
                    userId.value = auth.currentUser.uid;
                }
            } else {
                await signInAnonymously(auth);
                userId.value = auth.currentUser.uid;
            }
        }
        console.log("Firebase Auth Ready. User ID:", userId.value);
    });
});
</script>

<style>
/* 전역 스타일은 src/assets/main.css에 정의되었으므로 여기서는 최소화 */
/* App.vue에만 필요한 스타일은 여기에 추가 */
</style>

4.5. 환경 변수 관리 (.env 파일)
API_BASE_URL과 같은 백엔드 API URL은 .env 파일에 저장하여 환경별로 관리하는 것이 좋습니다.

.env 파일 생성:
프로젝트 루트에 .env 파일을 생성합니다.

# .env
VUE_APP_API_BASE_URL=http://localhost:8080/api

참고: Vue CLI는 VUE_APP_으로 시작하는 환경 변수만 클라이언트 측 코드에서 접근할 수 있도록 노출합니다.

코드에서 환경 변수 사용:
process.env.VUE_APP_API_BASE_URL을 사용하여 접근합니다.

// 각 뷰 컴포넌트의 <script> 섹션 또는 별도의 API 서비스 파일
const API_BASE_URL = process.env.VUE_APP_API_BASE_URL;

4.6. Firebase 및 전역 변수 처리
이전 HTML 파일에서 사용된 __firebase_config 및 __initial_auth_token, __app_id와 같은 전역 변수는 Vue CLI 환경에서는 직접 접근하기 어렵습니다. 이를 처리하는 몇 가지 방법이 있습니다.

가장 간단한 방법 (개발/테스트용): public/index.html에 <script> 태그를 통해 이 변수들을 전역으로 정의하고, Vue 앱에서 window.__firebase_config 등으로 접근합니다. (이전 HTML 파일에서 사용된 방식과 유사)

<!-- public/index.html -->
<head>
    <!-- ... -->
    <script>
        // Canvas 환경에서 제공되는 전역 변수라고 가정
        window.__firebase_config = '{"apiKey": "...", "authDomain": "...", ...}';
        window.__initial_auth_token = 'your_initial_auth_token_if_any';
        window.__app_id = 'your-app-id';
    </script>
    <!-- ... -->
</head>

그리고 Vue 컴포넌트에서 const firebaseConfig = JSON.parse(window.__firebase_config); 와 같이 사용합니다.

더 견고한 방법 (프로덕션용):

환경 변수 사용: Firebase 설정 자체를 .env 파일에 저장하고 빌드 시점에 주입합니다. (보안상 권장되지 않음, 특히 API 키)

백엔드 API를 통한 전달: Firebase 설정이나 초기 인증 토큰을 백엔드 API를 통해 프론트엔드로 전달하는 방식입니다.

Firebase SDK 초기화 분리: src/main.js에서 Firebase를 한 번만 초기화하고, provide/inject 또는 Vuex/Pinia를 통해 db 및 auth 인스턴스를 컴포넌트에 제공하는 것이 좋습니다.

src/main.js에서 Firebase 초기화 예시:

// src/main.js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'
import './assets/main.css'

import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';

const app = createApp(App)

// Firebase 초기화 (전역 변수가 있다면 사용)
const firebaseConfig = JSON.parse(typeof window.__firebase_config !== 'undefined' ? window.__firebase_config : '{}');
const firebaseApp = initializeApp(firebaseConfig);
const db = getFirestore(firebaseApp);
const auth = getAuth(firebaseApp);
const appId = typeof window.__app_id !== 'undefined' ? window.__app_id : 'default-app-id';

// 인증 처리 (App.vue 또는 전역 훅에서 처리)
onAuthStateChanged(auth, async (user) => {
    if (!user) {
        if (typeof window.__initial_auth_token !== 'undefined' && window.__initial_auth_token) {
            try {
                await signInWithCustomToken(auth, window.__initial_auth_token);
            } catch (error) {
                console.error("Custom token sign-in failed:", error);
                await signInAnonymously(auth);
            }
        } else {
            await signInAnonymously(auth);
        }
    }
    console.log("Firebase Auth Ready. User ID:", auth.currentUser?.uid);
});

// Vue 앱에 Firebase 인스턴스 주입 (provide/inject 패턴)
app.provide('db', db);
app.provide('auth', auth);
app.provide('appId', appId);
app.provide('userId', ref(auth.currentUser?.uid)); // userId는 반응형으로

app.use(router)
app.use(store)

app.mount('#app')

그리고 각 컴포넌트에서 import { inject } from 'vue'; 후 const db = inject('db'); 등으로 사용합니다.

4.7. Google Maps 및 Chart.js 사용
Google Maps: RobotLocationView.vue 컴포넌트의 <script setup> 섹션에서 initMap 함수를 호출하고, google.maps 객체가 로드되었는지 확인합니다.

Chart.js: SensorDataChartView.vue 컴포넌트의 <script setup> 섹션에서 Chart 객체를 사용하여 그래프를 그립니다.

4.8. API 호출 로직 통합
각 뷰 컴포넌트(DeviceManagementView.vue, DeviceStatusView.vue 등)에서 axios를 사용하여 Spring Boot 백엔드 API를 호출하는 로직을 통합합니다. 에러 처리(alert 메시지)도 각 뷰 컴포넌트의 catch 블록에 추가합니다.

5단계: 개발 서버 실행 및 테스트
모든 변경 사항을 적용한 후, 개발 서버를 다시 시작하여 애플리케이션이 정상적으로 작동하는지 확인합니다.

npm run serve

이 가이드를 통해 Visual Studio Code에서 Vue.js 프로젝트를 체계적으로 생성하고, 필요한 외부 라이브러리 및 기능을 통합하여 이전의 단일 HTML 파일 기능을 분리된 컴포넌트 기반의 구조로 구현할 수 있습니다.